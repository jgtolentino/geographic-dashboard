import { serve } from "https://deno.land/std@0.168.0/http/server.ts"
import { createClient } from 'https://esm.sh/@supabase/supabase-js@2.45.2'

const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',
}

// Chart type definitions
interface ChartDefinition {
  id: string
  type: 'bar' | 'line' | 'pie' | 'donut' | 'scatter' | 'area' | 'heatmap' | 'kpi' | 'map' | 'stacked' | 'combo' | 'small_multiple'
  title: string
  x_axis?: string
  y_axis?: string
  series?: any[]
  legend?: boolean
  filters?: string[]
  position: { row: number; col: number; width: number; height: number }
}

interface DashboardContext {
  charts: ChartDefinition[]
  layout: { rows: number; columns: number }
  filters: string[]
  kpis: { label: string; value: string; change?: string }[]
  theme: 'light' | 'dark'
}

// Vision analysis prompt
const VISION_PROMPT = `Analyze this dashboard screenshot and extract:
1. All charts with their types (bar, line, pie, etc.)
2. Chart titles, axis labels, and legends
3. Layout structure (grid positions)
4. Interactive elements (filters, dropdowns, tabs)
5. KPI cards and metrics
6. Color scheme and theme

Return a structured JSON with all dashboard elements and their properties.`

// OCR analysis for text extraction
async function analyzeImageWithVision(imageBase64: string): Promise<any> {
  const openAIKey = Deno.env.get('OPENAI_API_KEY')
  
  if (!openAIKey) {
    throw new Error('OpenAI API key not configured')
  }

  const response = await fetch('https://api.openai.com/v1/chat/completions', {
    method: 'POST',
    headers: {
      'Authorization': `Bearer ${openAIKey}`,
      'Content-Type': 'application/json',
    },
    body: JSON.stringify({
      model: 'gpt-4-vision-preview',
      messages: [
        {
          role: 'user',
          content: [
            { type: 'text', text: VISION_PROMPT },
            { type: 'image_url', image_url: { url: `data:image/jpeg;base64,${imageBase64}` } }
          ]
        }
      ],
      max_tokens: 4096,
      temperature: 0.2
    }),
  })

  if (!response.ok) {
    throw new Error(`Vision API error: ${response.statusText}`)
  }

  const data = await response.json()
  return JSON.parse(data.choices[0].message.content)
}

// Generate React/TSX code from context
function generateReactCode(context: DashboardContext): string {
  const chartImports = new Set<string>()
  const chartComponents: string[] = []

  // Determine required imports
  context.charts.forEach(chart => {
    if (['bar', 'line', 'area', 'scatter'].includes(chart.type)) {
      chartImports.add('recharts')
    } else if (['pie', 'donut'].includes(chart.type)) {
      chartImports.add('recharts-pie')
    }
  })

  // Generate chart components
  context.charts.forEach(chart => {
    chartComponents.push(generateChartComponent(chart))
  })

  // Build the complete dashboard code
  return `import React, { useState, useEffect } from 'react'
${chartImports.has('recharts') ? `import { BarChart, Bar, LineChart, Line, AreaChart, Area, ScatterChart, Scatter, XAxis, YAxis, CartesianGrid, Tooltip, Legend, ResponsiveContainer } from 'recharts'` : ''}
${chartImports.has('recharts-pie') ? `import { PieChart, Pie, Cell } from 'recharts'` : ''}
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from '@/components/ui/card'
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@/components/ui/select'

// Generated by ChartVision AI
export default function Dashboard() {
  const [filters, setFilters] = useState({})
  const [data, setData] = useState({})

  useEffect(() => {
    // TODO: Fetch actual data from your API
    fetchDashboardData()
  }, [filters])

  const fetchDashboardData = async () => {
    // Implement your data fetching logic here
  }

  return (
    <div className="min-h-screen bg-background p-6">
      <div className="mx-auto max-w-7xl">
        <h1 className="mb-6 text-3xl font-bold">Dashboard</h1>
        
        {/* Filters */}
        ${context.filters.length > 0 ? generateFiltersSection(context.filters) : ''}
        
        {/* KPI Cards */}
        ${context.kpis.length > 0 ? generateKPISection(context.kpis) : ''}
        
        {/* Charts Grid */}
        <div className="grid grid-cols-${context.layout.columns} gap-6">
          ${chartComponents.join('\n          ')}
        </div>
      </div>
    </div>
  )
}`
}

function generateChartComponent(chart: ChartDefinition): string {
  const { type, title, x_axis, y_axis } = chart
  
  switch (type) {
    case 'bar':
      return `<Card className="col-span-${chart.position.width}">
            <CardHeader>
              <CardTitle>${title}</CardTitle>
            </CardHeader>
            <CardContent>
              <ResponsiveContainer width="100%" height={300}>
                <BarChart data={data.${chart.id} || []}>
                  <CartesianGrid strokeDasharray="3 3" />
                  <XAxis dataKey="${x_axis || 'name'}" />
                  <YAxis />
                  <Tooltip />
                  <Legend />
                  <Bar dataKey="${y_axis || 'value'}" fill="#8884d8" />
                </BarChart>
              </ResponsiveContainer>
            </CardContent>
          </Card>`
    
    case 'line':
      return `<Card className="col-span-${chart.position.width}">
            <CardHeader>
              <CardTitle>${title}</CardTitle>
            </CardHeader>
            <CardContent>
              <ResponsiveContainer width="100%" height={300}>
                <LineChart data={data.${chart.id} || []}>
                  <CartesianGrid strokeDasharray="3 3" />
                  <XAxis dataKey="${x_axis || 'name'}" />
                  <YAxis />
                  <Tooltip />
                  <Legend />
                  <Line type="monotone" dataKey="${y_axis || 'value'}" stroke="#8884d8" />
                </LineChart>
              </ResponsiveContainer>
            </CardContent>
          </Card>`
    
    case 'pie':
    case 'donut':
      return `<Card className="col-span-${chart.position.width}">
            <CardHeader>
              <CardTitle>${title}</CardTitle>
            </CardHeader>
            <CardContent>
              <ResponsiveContainer width="100%" height={300}>
                <PieChart>
                  <Pie
                    data={data.${chart.id} || []}
                    cx="50%"
                    cy="50%"
                    ${type === 'donut' ? 'innerRadius={60}' : ''}
                    outerRadius={80}
                    fill="#8884d8"
                    dataKey="value"
                  >
                    {(data.${chart.id} || []).map((entry, index) => (
                      <Cell key={\`cell-\${index}\`} fill={COLORS[index % COLORS.length]} />
                    ))}
                  </Pie>
                  <Tooltip />
                  ${chart.legend ? '<Legend />' : ''}
                </PieChart>
              </ResponsiveContainer>
            </CardContent>
          </Card>`
    
    case 'kpi':
      return `<Card className="col-span-${chart.position.width}">
            <CardHeader>
              <CardTitle className="text-sm text-muted-foreground">${title}</CardTitle>
            </CardHeader>
            <CardContent>
              <div className="text-2xl font-bold">{data.${chart.id}?.value || 'â€”'}</div>
              {data.${chart.id}?.change && (
                <p className="text-xs text-muted-foreground">
                  {data.${chart.id}.change}
                </p>
              )}
            </CardContent>
          </Card>`
    
    default:
      return `<Card className="col-span-${chart.position.width}">
            <CardHeader>
              <CardTitle>${title}</CardTitle>
            </CardHeader>
            <CardContent>
              <div className="flex h-[300px] items-center justify-center text-muted-foreground">
                ${type} chart placeholder
              </div>
            </CardContent>
          </Card>`
  }
}

function generateFiltersSection(filters: string[]): string {
  return `<div className="mb-6 flex gap-4">
          ${filters.map(filter => `
          <Select onValueChange={(value) => setFilters({...filters, ${filter.toLowerCase().replace(/\s+/g, '_')}: value})}>
            <SelectTrigger className="w-[180px]">
              <SelectValue placeholder="${filter}" />
            </SelectTrigger>
            <SelectContent>
              <SelectItem value="all">All</SelectItem>
              {/* Add more options based on your data */}
            </SelectContent>
          </Select>`).join('\n          ')}
        </div>`
}

function generateKPISection(kpis: any[]): string {
  return `<div className="mb-6 grid grid-cols-4 gap-4">
          ${kpis.map(kpi => `
          <Card>
            <CardHeader className="pb-2">
              <CardTitle className="text-sm text-muted-foreground">${kpi.label}</CardTitle>
            </CardHeader>
            <CardContent>
              <div className="text-2xl font-bold">${kpi.value}</div>
              ${kpi.change ? `<p className="text-xs text-muted-foreground">${kpi.change}</p>` : ''}
            </CardContent>
          </Card>`).join('\n          ')}
        </div>`
}

serve(async (req) => {
  // Handle CORS
  if (req.method === 'OPTIONS') {
    return new Response('ok', { headers: corsHeaders })
  }

  try {
    const supabaseClient = createClient(
      Deno.env.get('SUPABASE_URL') ?? '',
      Deno.env.get('SUPABASE_SERVICE_ROLE_KEY') ?? '',
      { auth: { persistSession: false } }
    )

    // Parse request
    const formData = await req.formData()
    const imageFile = formData.get('image') as File
    
    if (!imageFile) {
      return new Response(
        JSON.stringify({ error: 'No image provided' }),
        { headers: { ...corsHeaders, 'Content-Type': 'application/json' }, status: 400 }
      )
    }

    // Convert image to base64
    const imageBuffer = await imageFile.arrayBuffer()
    const imageBase64 = btoa(String.fromCharCode(...new Uint8Array(imageBuffer)))

    // Analyze image with Vision API
    console.log('Analyzing dashboard screenshot...')
    const visionAnalysis = await analyzeImageWithVision(imageBase64)

    // Build dashboard context
    const context: DashboardContext = {
      charts: visionAnalysis.charts || [],
      layout: visionAnalysis.layout || { rows: 2, columns: 2 },
      filters: visionAnalysis.filters || [],
      kpis: visionAnalysis.kpis || [],
      theme: visionAnalysis.theme || 'light'
    }

    // Generate React code
    const reactCode = generateReactCode(context)

    // Log usage for analytics
    await supabaseClient
      .from('chartvision_usage')
      .insert({
        request_id: crypto.randomUUID(),
        chart_count: context.charts.length,
        filter_count: context.filters.length,
        kpi_count: context.kpis.length,
        response_time_ms: Date.now(),
        created_at: new Date().toISOString()
      })

    // Return response
    return new Response(
      JSON.stringify({
        context_json: context,
        react_code: reactCode,
        metadata: {
          charts_detected: context.charts.length,
          filters_detected: context.filters.length,
          kpis_detected: context.kpis.length,
          layout: context.layout
        }
      }),
      { headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
    )

  } catch (error) {
    console.error('ChartVision error:', error)
    return new Response(
      JSON.stringify({ 
        error: error.message,
        details: 'Failed to analyze dashboard screenshot'
      }),
      { headers: { ...corsHeaders, 'Content-Type': 'application/json' }, status: 500 }
    )
  }
})

// Color palette for charts
const COLORS = ['#0088FE', '#00C49F', '#FFBB28', '#FF8042', '#8884D8', '#82CA9D']